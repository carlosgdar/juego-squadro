<!DOCTYPE html>
<html lang="es">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Squadro — Juego Final</title>
<style>
    :root{
    --size: min(92vmin, 900px);
    --step-duration: 1000ms; /* 1s entre hoyos */
  }
  *{box-sizing:border-box;margin:0;padding:0}
  body{
    font-family: system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial;
    background: url('img/Fondo.png') center/cover no-repeat fixed;
    display:flex;
    flex-direction:column;
    align-items:center;
    gap:12px;
    min-height:100vh;
    padding:16px;
    color:#fff;
  }

  #status{font-weight:700;padding:8px 12px;background:rgba(0,0,0,0.45);border-radius:10px}
  .controls{display:flex;gap:8px;flex-wrap:wrap;justify-content:center}
  button{padding:10px 16px;border-radius:10px;border:2px solid #ffd700;background:#111;color:#ffd700;cursor:pointer;font-weight:700}
  button:hover{transform:translateY(-3px);background:#ffd700;color:#000}
  button:disabled{opacity:.45;cursor:not-allowed;transform:none}

  #board-container{
    width:var(--size);
    height:var(--size);
    position:relative;
    border-radius:18px;
    overflow:hidden;
    box-shadow:0 20px 60px rgba(0,0,0,.6);
    background: url('img/Tablero.png') center/contain no-repeat;
    background-size:100% 100%;
  }

  .overlay{position:absolute;inset:0;pointer-events:none}

  .piece{
    position:absolute;
    width:80px; height:80px;
    transform:translate(-50%,-50%);
    transition:left 260ms cubic-bezier(.2,.9,.3,1), top 260ms cubic-bezier(.2,.9,.3,1);
    pointer-events:auto;
    z-index:20;
    user-select:none;
    background-size:contain;
    background-repeat:no-repeat;
    background-position:center;
  }
  .p1{background-image:url('img/amarillo.png')}
  .p2{background-image:url('img/rojo.png');filter:brightness(.95)}
  .piece.completed{opacity:.45;transform:translate(-50%,-50%) scale(.85)}

  #winner-message{min-height:48px}

  @media (max-width:520px){
    button{padding:8px 10px;font-size:14px}
    .piece{width:70px;height:70px}
  }
</style>
</head>
<body>
  <div id="status">Cargando...</div>
  <div id="winner-message"></div>

  <div id="board-container" aria-label="Tablero Squadro">
    <div class="overlay" id="overlay"></div>
  </div>

  <div class="controls">
    <button id="reset">Jugar de nuevo</button>
    <button id="undo" disabled>Deshacer</button>
  </div>

<script>
/* ====== REGLAS ====== */
const STEPS_OUT_P1 = [3,1,2,1,3];
const STEPS_BACK_P1 = [1,3,2,3,1];
const STEPS_OUT_P2 = [1,3,2,3,1];
const STEPS_BACK_P2 = [3,1,2,1,3];
const CENTRAL_START = 6, CENTRAL_END = 10;
const WIN_CONDITION = 4;

/* ====== ESTADO ====== */
let state = {
  p1: Array.from({length:5}, (_,i) => ({ lane:i+1, pos:0, dir:1, turned:false, done:false, horizontal:true })),
  p2: Array.from({length:5}, (_,i) => ({ lane:i+1, pos:0, dir:1, turned:false, done:false, horizontal:false })),
  turn: 1, p1Done: 0, p2Done: 0
};
const history = [];
const tracks = new Map();

/* ====== UTIL ====== */
const boardContainer = document.getElementById('board-container');
const overlay = document.getElementById('overlay');
const statusEl = document.getElementById('status');
const winnerEl = document.getElementById('winner-message');

function getBoardSize(){ return boardContainer.clientWidth; }

/* ====== COORDENADAS EXACTAS (TUS VALORES) ====== */
function buildTracks(){
  tracks.clear();

  const holeX = [40, 117, 196, 275, 353, 433, 117, 196, 275, 353, 433, 433, 433, 433, 433, 433];
  const holeY = [40, 120, 201, 278, 358, 436, 120, 201, 278, 358, 436, 40, 40, 40, 40, 40];

  // P1: Horizontal - top fijo
  const p1Top = { h1:120, h2:201, h3:278, h4:358, h5:436 };
  for (let lane=1; lane<=5; lane++){
    const y = p1Top[`h${lane}`];
    const positions = holeX.map(x => ({ x: Math.round(x), y: Math.round(y) }));
    tracks.set(`h${lane}`, { positions });
  }

  // P2: Vertical - left fijo
  const p2Left = { v1:117, v2:196, v3:275, v4:353, v5:433 };
  for (let lane=1; lane<=5; lane++){
    const x = p2Left[`v${lane}`];
    const positions = holeY.map(y => ({ x: Math.round(x), y: Math.round(y) }));
    tracks.set(`v${lane}`, { positions });
  }
}

/* ====== RENDER ====== */
function render(){
  Array.from(overlay.querySelectorAll('.piece')).forEach(n => n.remove());

  state.p1.forEach(p => {
    const t = tracks.get(`h${p.lane}`);
    if (!t) return;
    const pos = t.positions[p.pos];
    const el = document.createElement('div');
    el.className = 'piece p1' + (p.done ? ' completed' : '');
    el.style.left = `${pos.x}px`;
    el.style.top = `${pos.y}px`;
    el.dataset.player = '1';
    el.dataset.lane = p.lane;
    el.id = `piece-h-${p.lane}`;
    if (state.turn === 1 && !p.done) el.style.cursor = 'pointer';
    overlay.appendChild(el);
  });

  state.p2.forEach(p => {
    const t = tracks.get(`v${p.lane}`);
    if (!t) return;
    const pos = t.positions[p.pos];
    const el = document.createElement('div');
    el.className = 'piece p2' + (p.done ? ' completed' : '');
    el.style.left = `${pos.x}px`;
    el.style.top = `${pos.y}px`;
    el.dataset.player = '2';
    el.dataset.lane = p.lane;
    el.id = `piece-v-${p.lane}`;
    overlay.appendChild(el);
  });

  updateStatus();
}

/* ====== MOVIMIENTO ====== */
function getTrack(piece){ return tracks.get(`${piece.horizontal ? 'h' : 'v'}${piece.lane}`); }

async function animateMove(el, from, to, desc){
  const t = getTrack(desc);
  if (!t) return;
  const dir = to > from ? 1 : -1;
  for (let i=1; i<=Math.abs(to-from); i++){
    const idx = from + dir * i;
    const pos = t.positions[idx];
    el.style.transition = 'left 260ms cubic-bezier(.2,.9,.3,1), top 260ms cubic-bezier(.2,.9,.3,1)';
    el.style.left = `${pos.x}px`;
    el.style.top = `${pos.y}px`;
    await new Promise(r => setTimeout(r, 280));
  }
  el.style.transition = '';
}

function movePieceWithPath(piece, myArr, oppArr){
  if (piece.done) return { myArr, oppArr, captured:false, completed:false, fromPos:piece.pos, toPos:piece.pos };

  const steps = piece.dir > 0
    ? (piece.horizontal ? STEPS_OUT_P1 : STEPS_OUT_P2)[piece.lane-1]
    : (piece.horizontal ? STEPS_BACK_P1 : STEPS_BACK_P2)[piece.lane-1];

  let target = piece.pos + piece.dir * steps;
  target = Math.max(0, Math.min(15, target));

  const track = getTrack(piece);
  let captured = null;
  for (let i=1; i<=Math.abs(target-piece.pos); i++){
    const idx = piece.pos + piece.dir * i;
    if (idx < CENTRAL_START || idx > CENTRAL_END) continue;
    const check = track.positions[idx];
    for (const op of oppArr){
      const opTrack = getTrack(op);
      if (opTrack && Math.abs(opTrack.positions[op.pos].x - check.x) < 8 && Math.abs(opTrack.positions[op.pos].y - check.y) < 8){
        captured = op;
        target = Math.max(0, Math.min(15, idx + piece.dir));
        break;
      }
    }
    if (captured) break;
  }

  let newPos = target;
  let newDir = piece.dir;
  let turned = piece.turned;
  let done = piece.done;
  if (piece.dir > 0 && newPos >= 15) { newPos = 15; newDir = -1; turned = true; }
  if (piece.dir < 0 && newPos <= 0 && turned) { newPos = 0; done = true; }

  const newPiece = {...piece, pos:newPos, dir:newDir, turned, done};
  const newMy = myArr.map(p => p === piece ? newPiece : {...p});
  let newOpp = oppArr.map(o => ({...o}));
  if (captured){
    const reset = captured.dir > 0 ? 0 : 15;
    newOpp = newOpp.map(o => o === captured ? {...o, pos: reset, dir: captured.dir>0?1:-1, turned:false, done:false} : o);
  }
  return { myArr: newMy, oppArr: newOpp, captured:!!captured, completed: done && !piece.done, fromPos: piece.pos, toPos: newPos };
}

/* ====== EVENTOS ====== */
overlay.addEventListener('click', async e => {
  if (state.turn !== 1) return;
  const el = e.target.closest('.piece');
  if (!el || el.dataset.player !== '1') return;
  const lane = +el.dataset.lane;
  const piece = state.p1.find(p => p.lane === lane);
  if (!piece || piece.done) return;

  saveState();
  const res = movePieceWithPath(piece, state.p1, state.p2);
  const pieceEl = document.getElementById(`piece-h-${lane}`);
  state.p1 = res.myArr;
  state.p2 = res.oppArr;
  if (res.completed) state.p1Done++;
  state.turn = 2;
  if (pieceEl && res.fromPos !== res.toPos) await animateMove(pieceEl, res.fromPos, res.toPos, piece);
  render();
  updateStatus();
  checkWin();
});

async function aiMove(){
  saveState();
  const moves = state.p2.filter(p => !p.done).map(p => {
    const res = movePieceWithPath(p, [...state.p2], [...state.p1]);
    const ns = {...state, p2: res.myArr, p1: res.oppArr, p2Done: state.p2Done + (res.completed?1:0), turn:1};
    return {piece: p, score: minimax(ns, 6, -Infinity, Infinity, true), res};
  });
  if (!moves.length) return void(state.turn = 1, render(), updateStatus());
  const best = moves.sort((a,b)=>b.score-a.score)[0];
  const el = document.getElementById(`piece-v-${best.piece.lane}`);
  state.p2 = best.res.myArr;
  state.p1 = best.res.oppArr;
  if (best.res.completed) state.p2Done++;
  state.turn = 1;
  if (el && best.res.fromPos !== best.res.toPos) await animateMove(el, best.res.fromPos, best.res.toPos, best.piece);
  render(); updateStatus(); checkWin();
}

function minimax(s, d, a, b, max){
  if (s.p2Done >= 4) return 1e9 + d*1000;
  if (s.p1Done >= 4) return -1e9 - d*1000;
  if (d === 0) return evaluate(s);
  const pieces = (max ? s.p2 : s.p1).filter(p=>!p.done);
  if (!pieces.length) return evaluate(s);
  if (max){
    let best = -Infinity;
    for (const p of pieces){
      const res = movePieceWithPath(p, max ? [...s.p2] : [...s.p1], max ? [...s.p1] : [...s.p2]);
      const ns = {...s, p2: max?res.myArr:res.oppArr, p1: max?res.oppArr:res.myArr,
        p1Done: s.p1Done + (!max && res.completed?1:0), p2Done: s.p2Done + (max && res.completed?1:0)};
      best = Math.max(best, minimax(ns, d-1, a, b, !max));
      if (best >= b) break; a = Math.max(a, best);
    }
    return best;
  } else {
    let best = Infinity;
    for (const p of pieces){
      const res = movePieceWithPath(p, max ? [...s.p2] : [...s.p1], max ? [...s.p1] : [...s.p2]);
      const ns = {...s, p2: max?res.myArr:res.oppArr, p1: max?res.oppArr:res.myArr,
        p1Done: s.p1Done + (!max && res.completed?1:0), p2Done: s.p2Done + (max && res.completed?1:0)};
      best = Math.min(best, minimax(ns, d-1, a, b, !max));
      if (best <= a) break; b = Math.min(b, best);
    }
    return best;
  }
}

function evaluate(s){
  let score = (s.p2Done - s.p1Done) * 100000;
  s.p2.forEach(p => { if(!p.done) score += (p.turned ? 15-p.pos : p.pos) * (p.turned?900:650); });
  s.p1.forEach(p => { if(!p.done) score -= (p.turned ? 15-p.pos : p.pos) * (p.turned?900:650); });
  return score;
}

/* ====== UTIL ====== */
function saveState(){ history.push({...state, p1:[...state.p1], p2:[...state.p2]}); document.getElementById('undo').disabled=false; }
function updateStatus(){
  if (state.p1Done >= 4) showWinner('p1');
  else if (state.p2Done >= 4) showWinner('p2');
  else statusEl.textContent = `Turno: ${state.turn===1?'Tú (Amarillo)':'IA (Rojo)'} • ${state.p1Done}-${state.p2Done}`;
}
function checkWin(){ if (  state.turn===2) setTimeout(aiMove, 500); }
function showWinner(p){ winnerEl.innerHTML = `<div style="font-size:24px;font-weight:700;color:#ffd700;background:rgba(0,0,0,.7);padding:12px;border-radius:12px">${p==='p1'?'GANASTE!':'GANÓ LA IA!'}</div>`; document.getElementById('undo').disabled=true; }

/* ====== INICIO ====== */
function createBoard(){
  buildTracks();
  state.p1.forEach(p=>p.pos=0); state.p2.forEach(p=>p.pos=0);
  state.p1Done = state.p2Done = 0; state.turn = 1;
  render(); updateStatus();
}

/* ====== BOTONES ====== */
document.getElementById('reset').onclick = () => { 
  history.length=0; 
  state = {p1:Array.from({length:5},(_,i)=>({lane:i+1,pos:0,dir:1,turned:false,done:false,horizontal:true})), 
           p2:Array.from({length:5},(_,i)=>({lane:i+1,pos:0,dir:1,turned:false,done:false,horizontal:false})), 
           turn:1, p1Done:0, p2Done:0}; 
  winnerEl.innerHTML=''; 
  createBoard(); 
  document.getElementById('undo').disabled=true; 
};
document.getElementById('undo').onclick = () => { 
  if(!history.length) return; 
  state = history.pop(); 
  render(); 
  updateStatus(); 
  document.getElementById('undo').disabled=!history.length; 
};
window.onresize = () => { buildTracks(); render(); };

createBoard();
</script>
</body>
</html>